use crate::scanner;
use crate::prompt;
use anyhow::{Context, Result};
use colored::Colorize;
use std::fs;
use std::path::Path;
use std::process::Command;
use std::time::SystemTime;

/// Project context gathered from filesystem (git, .env, compose files, etc.)
struct ProjectContext {
    dir_name: String,
    has_git: bool,
    git_remote: Option<String>,
    has_env_file: bool,
    compose_files: Vec<String>,
    has_dockerfile: bool,
}

fn gather_project_context(dir: &Path) -> ProjectContext {
    let dir_name = dir
        .file_name()
        .map(|n| n.to_string_lossy().to_string())
        .unwrap_or_else(|| "app".to_string());

    let compose_files: Vec<String> = [
        "docker-compose.yml",
        "docker-compose.yaml",
        "docker-compose.prod.yml",
        "docker-compose.prod.yaml",
    ]
    .iter()
    .filter(|f| dir.join(f).exists())
    .map(|f| f.to_string())
    .collect();

    let has_dockerfile = dir.join("Dockerfile").exists();
    let has_git = dir.join(".git").exists();
    let git_remote = if has_git {
        Command::new("git")
            .args(["remote", "get-url", "origin"])
            .current_dir(dir)
            .output()
            .ok()
            .and_then(|o| {
                if o.status.success() {
                    Some(String::from_utf8_lossy(&o.stdout).trim().to_string())
                } else {
                    None
                }
            })
    } else {
        None
    };

    let has_env_file = dir.join(".env").exists();

    ProjectContext {
        dir_name,
        has_git,
        git_remote,
        has_env_file,
        compose_files,
        has_dockerfile,
    }
}

/// Check if any docker-compose files exist
fn has_compose_files(dir: &Path) -> bool {
    dir.join("docker-compose.yml").exists()
        || dir.join("docker-compose.yaml").exists()
        || dir.join("docker-compose.prod.yml").exists()
        || dir.join("docker-compose.prod.yaml").exists()
}

/// Generate ops.toml content (project mode)
fn generate_ops_toml(
    project_name: &str,
    port: u16,
    domain: &Option<String>,
    env_files: &[(String, String)],
    compose_files: &[String],
) -> String {
    let mut out = String::new();

    let now = humantime::format_rfc3339_seconds(SystemTime::now());
    out.push_str(&format!(
        "# Generated by ops v{}\n# Docs: https://docs.ops.autos\n# GitHub: https://github.com/ops3000/ops-cli\n# Created: {}\n\n",
        env!("CARGO_PKG_VERSION"),
        now
    ));

    out.push_str(&format!("project = \"{}\"\n", project_name));
    out.push_str(&format!("deploy_path = \"/opt/{}\"\n", project_name));

    out.push_str("\n[deploy]\n");
    out.push_str("source = \"push\"\n");

    if compose_files.is_empty() {
        out.push_str("compose_files = [\"docker-compose.yml\"]\n");
    } else {
        let files: Vec<String> = compose_files.iter().map(|f| format!("\"{}\"", f)).collect();
        out.push_str(&format!("compose_files = [{}]\n", files.join(", ")));
    }

    // [[apps]]
    out.push_str(&format!(
        "\n[[apps]]\nname = \"{}\"\nservices = [\"{}\"]\n",
        project_name, project_name
    ));

    // [[routes]]
    if let Some(ref d) = domain {
        out.push_str(&format!(
            "\n[[routes]]\ndomain = \"{}\"\nport = {}\nssl = true\n",
            d, port
        ));
    } else {
        out.push_str(&format!(
            "\n# [[routes]]\n# domain = \"app.example.com\"\n# port = {}\n# ssl = true\n",
            port
        ));
    }

    // env_files
    for (local, remote) in env_files {
        out.push_str(&format!(
            "\n[[env_files]]\nlocal = \"{}\"\nremote = \"{}\"\n",
            local, remote
        ));
    }

    // healthchecks
    out.push_str(&format!(
        "\n[[healthchecks]]\nname = \"{}\"\nurl = \"http://localhost:{}\"\n",
        project_name, port
    ));

    out
}

/// ops launch — scan project, generate Dockerfile + docker-compose.yml + ops.toml
pub async fn handle_launch(output: String, interactive: bool) -> Result<()> {
    o_step!();
    o_step!("{}", "OPS Launch".cyan().bold());
    o_step!("{}", "══════════".cyan());
    o_step!();

    // 1. Scan project
    let source_dir = std::env::current_dir().context("Cannot get current directory")?;
    o_step!("{}", "Scanning project...".cyan());

    let scan_result = scanner::scan(&source_dir)?;
    let ctx = gather_project_context(&source_dir);

    // 2. Print scan results
    if let Some(ref info) = scan_result {
        o_success!("  {} {}", "✔".green(), info.family.cyan().bold());
        if let Some(ref ver) = info.version {
            if let Some(ref pm) = info.package_manager {
                o_success!("  {} {} {}, {}", "✔".green(), info.framework.display_name(), ver, pm);
            } else {
                o_success!("  {} {} {}", "✔".green(), info.framework.display_name(), ver);
            }
        }
        o_success!("  {} Port: {}", "✔".green(), info.port.to_string().yellow());
        for note in &info.notes {
            o_warn!("  {} {}", "ℹ".yellow(), note);
        }
    } else {
        o_warn!("  {} No framework detected", "!".yellow());
    }

    if ctx.has_git {
        if let Some(ref remote) = ctx.git_remote {
            o_success!("  {} Git: {}", "✔".green(), remote);
        }
    }
    if ctx.has_env_file {
        o_success!("  {} .env found", "✔".green());
    }
    o_detail!();

    // 3. Check existing ops.toml
    if Path::new(&output).exists() && interactive {
        if !prompt::confirm_no(&format!("{} already exists. Overwrite?", output), interactive)? {
            o_warn!("Aborted.");
            return Ok(());
        }
        o_detail!();
    }

    // 4. Minimal interactive prompts
    let project_name = prompt::input_with_default("Project name", &ctx.dir_name, interactive)?;

    let port = if let Some(ref info) = scan_result {
        let p = prompt::input_with_default("Port", &info.port.to_string(), interactive)?;
        p.parse().unwrap_or(info.port)
    } else {
        let p = prompt::input_with_default("Port", "8080", interactive)?;
        p.parse().unwrap_or(8080)
    };

    let domain = prompt::input_optional("Domain (e.g. app.example.com, enter to skip):", interactive)?;
    let domain = if domain.is_empty() { None } else { Some(domain) };

    let env_files = if ctx.has_env_file {
        if prompt::confirm_yes("Sync .env to remote?", interactive)? {
            vec![(".env".to_string(), ".env".to_string())]
        } else {
            vec![]
        }
    } else {
        vec![]
    };

    o_detail!();

    // 5. Generate files
    let mut generated = Vec::new();

    // Dockerfile
    if let Some(ref info) = scan_result {
        if !ctx.has_dockerfile {
            let dockerfile = scanner::dockerfile::render_dockerfile(info);
            fs::write(source_dir.join("Dockerfile"), &dockerfile)
                .context("Failed to write Dockerfile")?;
            generated.push("Dockerfile");
        } else {
            o_detail!("  {} Dockerfile already exists, skipping", "→".dimmed());
        }
    }

    // docker-compose.yml
    if let Some(ref info) = scan_result {
        if !has_compose_files(&source_dir) {
            let compose = scanner::dockerfile::render_compose(&project_name, info);
            fs::write(source_dir.join("docker-compose.yml"), &compose)
                .context("Failed to write docker-compose.yml")?;
            generated.push("docker-compose.yml");
        } else {
            o_detail!("  {} docker-compose.yml already exists, skipping", "→".dimmed());
        }
    }

    // .dockerignore
    if let Some(ref info) = scan_result {
        if !source_dir.join(".dockerignore").exists() {
            let ignore = scanner::dockerfile::render_dockerignore(info);
            fs::write(source_dir.join(".dockerignore"), &ignore)
                .context("Failed to write .dockerignore")?;
            generated.push(".dockerignore");
        }
    }

    // Use existing compose files if present, else the one we generated
    let compose_files = if !ctx.compose_files.is_empty() {
        ctx.compose_files.clone()
    } else {
        vec!["docker-compose.yml".to_string()]
    };

    // ops.toml
    let toml_content = generate_ops_toml(&project_name, port, &domain, &env_files, &compose_files);
    fs::write(&output, &toml_content)
        .with_context(|| format!("Failed to write {}", output))?;
    generated.push("ops.toml");

    // 6. Print results
    o_step!("{}", "Generated:".cyan().bold());
    for f in &generated {
        o_success!("  {} {}", "✔".green(), f.cyan());
    }

    o_detail!();
    o_step!("{}", "Next steps:".cyan().bold());
    o_detail!("  {}          # deploy to server", "ops deploy".cyan());

    Ok(())
}
